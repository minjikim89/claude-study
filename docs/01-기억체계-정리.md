# Claude Code 기억 체계 & Agentic 비교 정리

---

## 1. Skill 실행 = 프롬프트 주입

Agentic 프레임워크(CrewAI, LangGraph 등)에서는 에이전트를 코드로 정의하지만,
Claude Code의 Skill은 **마크다운 파일을 컨텍스트에 주입**하는 방식이다.

### Agentic 프레임워크 vs Claude Code

| Agentic 프레임워크 | Claude Code |
|---|---|
| 코드로 Agent 객체를 정의 → 런타임이 실행 | 마크다운 파일 하나 → 컨텍스트에 주입 → Claude가 읽고 따름 |

| Agentic 프레임워크 개념 | Claude Code 대응 |
|---|---|
| **Role** (역할) | SKILL.md에 텍스트로 작성 |
| **Backstory** (배경) | SKILL.md에 텍스트로 작성 |
| **Task** (할 일) | SKILL.md에 텍스트로 작성 |
| **Tools** (도구) | Skill이 정의하지 않음. Claude Code가 이미 가진 도구(Bash, Read, Write 등)를 그대로 사용 |

### "Skill을 실행한다"의 실제 의미

```
1. 사용자가 "/day1-test-skill" 입력
2. Claude Code가 .claude/skills/day1-test-skill/SKILL.md 파일을 찾음
3. 그 내용을 컨텍스트 윈도우에 주입 (= 시스템 프롬프트에 추가)
4. Claude가 그 지시사항을 읽고 따라서 응답
```

> "실행"이라기보다는 **"지시문을 읽게 하는 것"**에 가깝다.
> 별도의 에이전트가 생성되는 게 아니라, **같은 Claude가 추가 지시를 받는 것**.

### 비유

| 개념 | 비유 |
|------|------|
| **Agentic 프레임워크** | 전문가를 **고용**해서 도구를 쥐어주고 일을 시킴 |
| **Claude Code Skill** | 이미 있는 비서에게 **레시피 카드를 건네줌** |

> Skill은 코드가 아니라 **마크다운**이므로 비개발자도 만들 수 있다.
> 복잡한 멀티에이전트가 필요하면 **Subagent**와 **Agent Teams** 기능을 사용한다.

---

## 2. Agentic 프레임워크 개념과 Claude Code 전체 대응

```
Agentic 프레임워크              Claude Code
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
System Prompt / Global       →  CLAUDE.md
  Role                            "한국어로 응답한다"
  Backstory                       "AI Native Camp 프로젝트"
  Constraints                     "STOP PROTOCOL을 따른다"

Task-specific Prompt         →  Skill (SKILL.md)
  Task Instructions               레시피 본문
  Reference Data                  references/ 폴더
  Scripts                         scripts/ 폴더

Long-term Memory             →  CLAUDE.md + Auto Memory
Working Memory               →  대화 컨텍스트
```

---

## 3. CLAUDE.md vs Skill — 둘 다 프롬프트 주입이지만 방식이 다르다

```
┌─────────────────────────────────────────────────────────┐
│                    컨텍스트 윈도우 (200k 토큰)             │
│                                                          │
│  ┌──────────────┐                                        │
│  │ CLAUDE.md    │ ← 항상 자동 로드. 세션 시작과 동시에 주입  │
│  │ (전역 규칙)   │                                        │
│  └──────────────┘                                        │
│                                                          │
│  ┌──────────────┐                                        │
│  │ Skill A      │ ← "/명령어" 입력할 때만 로드             │
│  │ (레시피)      │                                        │
│  └──────────────┘                                        │
│                                                          │
│  ┌──────────────┐                                        │
│  │ 대화 내용     │ ← 사용자와 Claude의 주고받은 메시지들     │
│  └──────────────┘                                        │
└─────────────────────────────────────────────────────────┘
```

### 핵심 차이

| | **CLAUDE.md** | **Skill** |
|---|---|---|
| **로딩 시점** | 매 세션 자동 | 호출할 때만 |
| **용도** | 프로젝트 전체에 적용되는 규칙 | 특정 작업의 레시피 |
| **길이** | 짧게 유지 (항상 읽히니까) | 길어도 OK (필요할 때만) |
| **비유** | 회사 사규 | 업무 매뉴얼 |
| **예시** | "한국어로 답해", "테스트 먼저 실행" | "/sync", "/day1-onboarding" |
| **여러 개 가능?** | 레벨별 3개 (전역, 프로젝트, 로컬) | 무제한 |

### CLAUDE.md의 3개 레벨

```
~/.claude/CLAUDE.md           ← 전역: 모든 프로젝트에 적용 (개인 선호)
./CLAUDE.md                   ← 프로젝트: 이 프로젝트에 적용 (팀 공유)
./CLAUDE.local.md             ← 로컬: 이 프로젝트 + 나만 적용 (git 무시)
```

세 파일이 모두 있으면 **전부 합쳐서** 시스템 프롬프트에 주입된다.

---

## 4. Claude Code의 기억 체계 — 전체 그림

Claude는 기본적으로 **대화가 끝나면 모든 걸 잊는다**.
이 휘발성을 극복하기 위한 기억 체계가 여러 층으로 존재한다.

### 수명 기준 분류

```
┌─────────────────────────────────────────────────────┐
│ 🔴 휘발성 (세션이 끝나면 사라짐)                       │
│                                                      │
│  • 대화 내용 (Messages)                               │
│  • 로드된 Skill 내용                                   │
└─────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────┐
│ 🟢 영구 (파일로 저장, 세션이 바뀌어도 유지)             │
│                                                      │
│  • CLAUDE.md (수동 규칙)                               │
│  • Auto Memory (자동 학습)                             │
│  • Skill 파일들 (디스크에 저장)                         │
└─────────────────────────────────────────────────────┘
```

### 영구 기억 3가지 비교

| | **CLAUDE.md** | **Auto Memory** | **Skill** |
|---|---|---|---|
| **뭐냐** | 규칙서 | 학습 노트 | 업무 레시피 |
| **비유** | 회사 사규 | 개인 메모장 | 요리 레시피북 |
| **누가 작성** | 사람 (수동) | Claude (자동) + 사람 | 사람 (수동) |
| **로딩 시점** | 매 세션 자동 | 매 세션 자동 | 호출할 때만 |
| **저장 위치** | 프로젝트 루트 | `~/.claude/projects/` | `.claude/skills/` |
| **용도** | "이렇게 해라" | "이걸 배웠다" | "이 작업은 이렇게" |
| **예시** | "한국어로 답해" | "이 유저는 표를 선호함" | "/sync로 리포트 생성" |

### 저장 위치 전체 맵

```
~/.claude/
├── CLAUDE.md                          ← 🌍 전역 규칙 (모든 프로젝트)
└── projects/
    └── <프로젝트명>/
        └── memory/
            └── MEMORY.md              ← 🧠 Auto Memory (프로젝트별 자동 학습)

프로젝트 루트/
├── CLAUDE.md                          ← 📋 프로젝트 규칙 (팀 공유, git 포함)
├── CLAUDE.local.md                    ← 🔒 로컬 규칙 (나만, git 무시)
└── .claude/
    └── skills/
        └── my-skill/
            └── SKILL.md               ← 📖 Skill (호출 시에만 로드)
```

---

## 5. 세션 시작 시 일어나는 일

```
새 세션 시작
  │
  ▼
┌─ 자동 로드 (매번) ──────────────────────────────┐
│                                                  │
│  1. ~/.claude/CLAUDE.md          (전역 규칙)      │
│  2. ./CLAUDE.md                  (프로젝트 규칙)   │
│  3. ./CLAUDE.local.md            (로컬 규칙)      │
│  4. Auto Memory (MEMORY.md)      (학습 내용)      │
│                                                  │
│  → 전부 합쳐서 시스템 프롬프트에 주입              │
└──────────────────────────────────────────────────┘
  │
  ▼
┌─ 대기 (필요할 때만) ────────────────────────────┐
│                                                  │
│  5. Skills (SKILL.md들)                          │
│     → 목록만 인식, 본문은 호출 시 로드            │
│                                                  │
└──────────────────────────────────────────────────┘
  │
  ▼
  대화 시작 🎯
```

---

## 6. Auto Memory 동작 방식

CLAUDE.md는 **내가 직접 쓰는** 규칙이고, Auto Memory는 **Claude가 스스로 적는** 메모이다.

```
대화 중 Claude가 패턴을 발견
  │
  ▼
"이 유저는 표 형식을 선호하는구나"
  │
  ▼
~/.claude/projects/<프로젝트>/memory/MEMORY.md에 자동 기록
  │
  ▼
다음 세션에서 자동으로 읽힘 → 처음부터 표로 정리해서 답변
```

`/memory` 명령어로 Auto Memory를 직접 확인하고 편집할 수 있다.

---

## 7. 한 줄 요약

```
CLAUDE.md  = 내가 Claude에게 주는 규칙     (항상 로드)
Memory     = Claude가 스스로 적는 학습 노트  (항상 로드)
Skill      = 특정 작업의 레시피              (호출 시 로드)
대화       = 지금 이 순간의 맥락             (세션 끝나면 소멸)
```

> 이 4가지 계층은 결국 **컨텍스트 윈도우(200k 토큰)를 효율적으로 쓰기 위한 설계**이다.
> 항상 필요한 건 자동 로드, 가끔 필요한 건 온디맨드 로드, 일시적인 건 대화에만 존재.

---

## 8. Subagent — 부하 직원

### 왜 필요한가?

컨텍스트 윈도우(200k 토큰)는 유한하다. 큰 작업을 메인 대화에서 직접 하면 컨텍스트가 빠르게 차버린다.
Subagent는 **독립된 공간에서 작업하고 결과만 보고**해서 메인 컨텍스트를 보호한다.

### 작동 원리: Blank Slate

```
┌─ 메인 Claude ──────────────────────────┐
│  대화 컨텍스트: [A, B, C, D, E...]     │
│                                        │
│  "PDF 분석해줘" ──┐                     │
│                   ▼                    │
│  ┌─ Subagent ──────────────┐           │
│  │ 컨텍스트: [blank slate]  │  ← 빈 상태에서 시작!
│  │ 작업: PDF 분석            │           │
│  │ (200페이지 읽음...)       │           │
│  │ 결과: 요약 3줄 ──────────┼──▶ 전달   │
│  └─────────────────────────┘           │
│                                        │
│  메인은 요약 3줄만 받음 → 컨텍스트 절약!  │
└────────────────────────────────────────┘
```

**핵심 특징:**
- **Blank Slate** — 메인 대화의 히스토리를 물려받지 않고 빈 상태에서 시작
- **독립 컨텍스트** — Subagent가 파일 200개를 읽어도 메인 컨텍스트는 깨끗
- **결과만 반환** — 요약된 결과만 메인에게 보고
- **1:1 관계** — 메인에게만 보고, 다른 Subagent와 소통 불가

### 내장 Subagent 종류

| Subagent | 특징 | 용도 |
|----------|------|------|
| **Explore** | 읽기 전용, 빠른 모델(Haiku) | 파일 탐색, 코드베이스 분석 |
| **Plan** | 읽기 전용 | 구현 계획 수립 |
| **General-purpose** | 모든 도구 사용 가능 | 복잡한 멀티스텝 작업 |
| **Bash** | Bash 도구만 | 터미널 명령 실행 |

### 커스텀 Subagent 만들기

`.claude/agents/my-reviewer.md` 파일을 만들면 나만의 전문가 Subagent를 정의할 수 있다:

```markdown
---
name: code-reviewer
description: 코드 품질과 보안을 검토합니다
tools: Read, Grep, Glob
model: sonnet
---

당신은 수석 코드 리뷰어입니다. 보안 문제와 성능을 집중 검토합니다.
```

도구(tools)를 제한할 수 있어서 **안전한 자동화**가 가능하다 (예: 읽기 전용 DB 조회 에이전트).

---

## 9. Agent Teams — 프로젝트 팀

### Subagent와의 결정적 차이

Subagent가 **부하 직원(1:1 보고)**이라면, Agent Teams는 **프로젝트 팀(팀원끼리 직접 소통)**이다.

```
┌─ 리더 ─────────────────────────────────────┐
│                                            │
│  ┌─ Agent A ─┐  ┌─ Agent B ─┐  ┌─ Agent C ─┐
│  │ 시장조사   │  │ 보고서    │  │ 발표자료   │
│  └─────┬─────┘  └─────┬─────┘  └─────┬─────┘
│        │              │              │
│        └──────── 메시지 ─────────────┘
│                    +
│            공유 태스크 리스트
└────────────────────────────────────────────┘
  Subagent: 리더에게만 보고
  Teams:    팀원끼리 직접 소통
```

### 비교표

| | **Subagent** | **Agent Teams** |
|---|---|---|
| **비유** | 부하 직원 | 프로젝트 팀 |
| **통신** | 메인에게만 보고 | 팀원끼리 직접 메시지 |
| **조율** | 메인이 전부 관리 | 공유 태스크 리스트로 자동 |
| **컨텍스트** | 독립 (결과만 반환) | 각자 완전 독립 세션 |
| **병렬성** | 제한적 | 높음 |
| **토큰 비용** | 낮음 | 높음 (N개 세션) |
| **활성화** | 기본 사용 가능 | 설정 필요 (실험적) |

### Agent Teams 활성화 방법

`~/.claude/settings.json`에 추가:

```json
{
  "env": {
    "CLAUDE_CODE_EXPERIMENTAL_AGENT_TEAMS": "1"
  }
}
```

### 사용 사례 구분

```
Subagent가 적합한 경우:
  - "이 PDF 요약해줘" (단일 작업 위임)
  - "코드베이스 구조 탐색해줘" (탐색 후 보고)

Agent Teams가 적합한 경우:
  - "3명의 전문가가 동시에 PR 리뷰" (병렬 + 토론)
  - "프론트/백엔드/테스트를 동시에 개발" (협업)
```

---

## 10. 전체 아키텍처 한눈에 보기

```
Claude Code 아키텍처
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
영구 기억     →  CLAUDE.md + Auto Memory   (항상 로드)
레시피        →  Skill                      (호출 시 로드)
외부 연결     →  MCP                        (외부 서비스 플러그)
작업 위임     →  Subagent                   (독립 공간, 결과만 보고)
팀 협업       →  Agent Teams                (독립 세션, 직접 소통)
```

> Agentic 프레임워크 대응:
> - **System Prompt / Global Config** → CLAUDE.md
> - **Long-term Memory** → CLAUDE.md + Auto Memory
> - **Working Memory** → 대화 컨텍스트
> - **Task-specific Prompt** → Skill
> - **Tool Calling (외부)** → MCP
> - **Tool Delegation** → Subagent
> - **Multi-agent Orchestration** → Agent Teams
