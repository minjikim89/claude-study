# Subagent — 독립 공간에서 일하는 부하 직원

## Subagent란?

Claude Code에서 대화하는 Claude는 **메인 에이전트** 하나다. 그런데 큰 작업을 메인 대화에서 직접 처리하면 컨텍스트 윈도우(200k 토큰)가 빠르게 차버린다.

Subagent는 이 문제를 해결한다: **독립된 공간에서 작업하고, 결과만 메인에게 보고**하는 구조다.

## 노코드 도구에서의 비유

| 노코드 도구 개념 | Claude Code Subagent |
|---|---|
| Zapier의 Sub-Zap (서브 워크플로우) | 메인 흐름에서 분기하여 별도 작업 수행 후 결과 반환 |
| Make의 Sub-scenario | 복잡한 로직을 분리해서 처리 |
| Notion의 링크드 데이터베이스 | 원본은 따로 있고, 필요한 정보만 가져와서 표시 |

## 왜 필요한가?

실제 시나리오로 설명하면:

**Subagent 없이** — 200페이지 PDF를 분석해달라고 하면:
```
메인 컨텍스트: [기존 대화] + [PDF 200페이지 전체] → 토큰 폭발
다른 작업을 하려면 컨텍스트가 이미 꽉 찬 상태
```

**Subagent 사용 시** — 같은 요청:
```
메인 컨텍스트: [기존 대화] + [요약 3줄만 수신] → 컨텍스트 깨끗
다른 작업 계속 가능
```

## 작동 원리: Blank Slate

Subagent의 핵심 특징은 **Blank Slate(백지 상태)** 시작이다.

```
┌─ 메인 Claude ──────────────────────────┐
│  대화 컨텍스트: [A, B, C, D, E...]     │
│                                        │
│  "PDF 분석해줘" ──┐                     │
│                   ▼                    │
│  ┌─ Subagent ──────────────┐           │
│  │ 컨텍스트: [blank slate]  │  ← 빈 상태에서 시작
│  │ 작업: PDF 분석            │           │
│  │ (200페이지 읽음...)       │           │
│  │ 결과: 요약 3줄 ──────────┼──▶ 전달   │
│  └─────────────────────────┘           │
│                                        │
│  메인은 요약 3줄만 받음 → 컨텍스트 절약   │
└────────────────────────────────────────┘
```

**Blank Slate가 의미하는 것:**
- 메인 대화의 히스토리를 물려받지 **않는다**
- Subagent는 지금까지 무슨 대화를 했는지 모른다
- 오직 **지시받은 작업에 대한 정보**만 가지고 시작한다
- 이것이 장점이다: 불필요한 컨텍스트 없이 작업에만 집중

## Subagent의 특성

| 특성 | 설명 |
|---|---|
| **Blank Slate** | 메인 대화의 히스토리를 물려받지 않고 빈 상태에서 시작 |
| **독립 컨텍스트** | Subagent가 파일 200개를 읽어도 메인 컨텍스트는 깨끗 |
| **결과만 반환** | 작업 과정은 버려지고 요약된 결과만 메인에게 보고 |
| **1:1 관계** | 메인에게만 보고, 다른 Subagent와 직접 소통 불가 |
| **일회성** | 작업 완료 후 사라짐 (영구 존재하지 않음) |

## 내장 Subagent 종류

Claude Code는 용도별로 최적화된 내장 Subagent를 제공한다.

| Subagent | 사용 가능한 도구 | 모델 | 용도 | 비유 |
|----------|----------------|------|------|------|
| **Explore** | 읽기 전용 (Read, Glob, Grep) | Haiku (빠르고 저렴) | 파일 탐색, 코드베이스 분석 | 도서관 사서 |
| **Plan** | 읽기 전용 | Sonnet/Opus | 구현 계획 수립, 아키텍처 설계 | 설계사 |
| **General-purpose** | 모든 도구 | Sonnet/Opus | 복잡한 멀티스텝 작업 | 만능 비서 |
| **Bash** | Bash만 | Sonnet/Opus | 터미널 명령 실행 | 시스템 관리자 |

### 각 Subagent의 사용 시점

**Explore** — "이 프로젝트 구조가 어떻게 돼있어?"
- 코드베이스를 빠르게 탐색
- 비용이 저렴한 Haiku 모델 사용
- 파일을 수정하지 않으므로 안전

**Plan** — "이 기능을 어떻게 구현하면 좋을까?"
- 코드를 읽고 계획만 세움
- 실제 코드 작성은 하지 않음

**General-purpose** — "이 PDF 분석해서 요약해줘"
- 모든 도구를 사용할 수 있어 복잡한 작업 가능
- 파일 읽기, 쓰기, 터미널 실행 모두 가능

**Bash** — "테스트 전체 실행해서 결과 알려줘"
- 터미널 명령만 실행
- 긴 빌드/테스트 과정의 결과만 보고

## 커스텀 Subagent 만들기

내장 Subagent로 부족하면 직접 만들 수 있다.

### 파일 위치
```
프로젝트/
└── .claude/
    └── agents/
        └── my-reviewer.md
```

### 작성 예시

```markdown
---
name: code-reviewer
description: 코드 품질과 보안을 검토합니다
tools: Read, Grep, Glob
model: sonnet
---

당신은 수석 코드 리뷰어입니다.

## 검토 항목
1. 보안 취약점 (SQL 인젝션, XSS 등)
2. 성능 이슈 (불필요한 루프, 메모리 누수)
3. 코드 가독성
4. 에러 처리 누락

## 출력 형식
| 파일 | 라인 | 심각도 | 내용 |
|------|------|--------|------|
```

### 커스텀 Subagent의 장점

- **도구 제한**: `tools` 필드로 사용 가능한 도구를 제한 → 안전한 자동화 가능
  - 예: 읽기 전용 DB 조회 에이전트 (Read, Grep만 허용)
- **모델 선택**: 간단한 작업은 저렴한 Haiku, 복잡한 작업은 Opus
- **역할 고정**: 항상 일관된 기준으로 작업 수행

## Subagent가 자동으로 사용되는 경우

사용자가 명시적으로 Subagent를 호출하지 않아도, Claude Code가 판단하여 자동으로 Subagent를 띄우는 경우가 있다:

- 코드베이스 탐색이 필요할 때 → **Explore** Subagent 자동 생성
- 복잡한 구현 계획을 세울 때 → **Plan** Subagent 자동 생성
- 병렬 처리가 효율적인 작업일 때 → 여러 Subagent 동시 생성

## 핵심 정리

- Subagent = **독립 공간에서 작업하고 결과만 보고**하는 하위 에이전트
- Blank Slate로 시작 → 메인 컨텍스트 오염 방지
- 4가지 내장 Subagent (Explore, Plan, General-purpose, Bash) + 커스텀 가능
- 커스텀 Subagent는 `.claude/agents/` 에 마크다운 파일로 정의
- 메인과 1:1 관계 — 다른 Subagent와 직접 소통 불가 (이게 Agent Teams와의 차이)
